# 문제 정의

- 대시보드 렌더링에 필요한 다양한 데이터 요청에 대한 API 설계
- 갱신주기가 긴 데이터와 짧은 데이터가 혼재
- 갱신주기가 짧은 시계열 데이터를 그래프로 그려야하며, 시간 척도가 다른 데이터가 하나의 그래프 위에 그려질 수 있음

---

# 분석

## 갱신 주기가 긴 데이터

#### 전략

- React-query와 같은 상태관리 라이브러리의 stale time으로 관리

---

## 갱신 주기가 짧은 데이터

#### 전략

- 각 데이터를 시간 별로 쌓는다. _(웹소켓 또는 폴링)_

- 폴링인 경우 : 필요한 데이터를 start - end로 요청
  - 1시간의 데이터가 필요하고 현재 시각이 12:00이라면 11:00 - 12:00 요청
  - 이후로는 내 마지막 데이터 - 현재까지 데이터를 요청하면 됨
    - 또는 서버의 캐싱 _(Redis 등)_ 을 믿고 매 요청마다 전체 데이터를 요청할 수도 있음
      - 서버의 캐싱을 믿더라도 데이터의 양 자체가 방대하다면 전송이 오래걸리는 것이 단점

- 웹소켓인 경우 : 최초 전체 수신 이후 받는 데이터를 시간 별로 쌓는다. Zustand/Jotai등을 이용하여 전역 UI업데이트 가능
  - credential의 경우 WebSocket이 Establish될 때 완료되므로 최초에만 전송
  - Res에는 id를 사용하지 않고 timestamp만 사용

### 데이터를 받는 두 가지 방법

#### 1. 데이터군별 데이터

- 각 데이터(ex. memory, cpu)별로 데이터를 받는다. 이는 주어진 데이터 별로 업데이트되는 주기가 다르기 때문
- 데이터 간 결합도를 낮게 유지 가능하지만, 그래프를 그릴 때 x축의 타임라인을 맞춰서 데이터를 정리해야 함

```typescript
// 예시 데이터 타입
interface MemoryUsage {
  timestamp: number;
  name: string;
  value: {};
}

interface CPUUsage {
  timestamp: number;
  name: string;
  value: {};
}

interface Store {
  memory: MemoryUsage[];
  cpu: CPUUsage[];
}
```

#### 2. 시간별 데이터

- 데이터별 시간척도를 동일하게 가져가므로 **그래프로 바로 그리기 용이**
- 항상 정해진 내용을 그리고 데이터별 조작을 하지 않는 용도라면 적합
- 서버에 한 번에 모든 데이터를 요청한다면 유효하지만 데이터를 따로 사용하기 위해서는 결국 분리해야 함

---

# 결론

### 전략

- 갱신주기와 관계없이 일반적인 Rest API 사용 (WebSocket사용하지 않음) -> _시계열 데이터가 최소 10초단위로 추정되기 때문_
- 갱신주기에 관계없이 **대시보드 패널 별 API 요청 훅 작성**
  - 원자적으로 데이터를 쪼개지 않고 패널 단위로 받아서 네트워크 요청 수를 적정 선으로 유지
    - 데이터 별(ex. memory, cpu)로 나누기엔 서버 요청 수가 많기 때문

### API 설계

공통 : Req에는 credential

#### 갱신주기가 긴 데이터

공통 : Res에는 id (필요 시createdAt, updatedAt) 포함

- Feature showcases
  - Req : count (ex. 6개)
  - Res : title, description, isFavorite

- Data source demos
  - Req : 요청 갯수 (ex. 6개)
  - Res : title, description, isFavorite

- What's new in Grafana Version
  - Req : count _(확장한다면 페이지 갯수, 또는 페이지별 요청)_
  - Res : version

```typescript
// 예시 요청 & 응답
'/api/featureShowcases?count=6' => {
  showcases: {
    id: string;
    title: string;
    description: string;
    isFavorite: boolean;
  }[];
}
```

#### 갱신주기가 짧은 데이터

- Memory/CPU, Logins

```typescript
// 예시 요청 & 응답
// start&end는 ISO 시간을 encode해서 요청, 또는 숫자 형태의 timestamp로 요청
'/api/systemResource?start=${start}&end=${start}' => {
  memory: { timestamp: number; value: number }[]; // 분당 1개
  cpu: { timestamp: number; value: number }[]; // 10초당 1개 (예시)
}
```

- Server Requests
  - 서버 목록과 각 데이터를 별도로 받음
  - ID와 이름은 그래프에서 필요 시 매칭하여 사용
  - 요구사항이 정확히 정의되어 있지 않아 _서버에서 해당 유저에게 할당된 서버목록을 함께 제공한다고 가정_

```typescript
// 예시 요청 & 응답
// start&end는 ISO 시간을 encode해서 요청, 또는 숫자 형태의 timestamp로 요청
'/api/serverRequests?start=${start}&end=${start}' => {
  servers: { id: string; name: string }[]; // 서버 목록
  payload: {
    serverId: string;
    data: {
      timestamp: number;
      value:number;
    }[];
  }[];
}
```

- Client side full page load, Traffic In/Out
  - 받은 데이터에 대한 상/하위 분류와 누적 Mean, Last를 클라이언트에서 구하는 것이 합리적. 서버는 DB 쿼리만 신경쓰도록 함
  - 데이터 양이 방대해서 전송자체가 오래걸리는 경우 서버에서 미리 계산에서 넘겨주는 방법도 대안이 될 수 있음

```typescript
// 예시 요청 & 응답
// start&end는 ISO 시간을 encode해서 요청, 또는 숫자 형태의 timestamp로 요청
'/api/pageLoadingTime?start=${start}&end=${start}' => {
  pageLoadingTime : {
    timestamp:number;
    elapsed: number[]; // 받은 후 정렬하여 상/하위 퍼센트 및 평균 등을 구한다
  }[];
}
``
```

---

끝
